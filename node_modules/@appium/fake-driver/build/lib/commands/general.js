"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const driver_1 = require("appium/driver");
const mixin_1 = require("./mixin");
const ORIENTATIONS = new Set(['LANDSCAPE', 'PORTRAIT']);
const GeneralMixin = {
    async title() {
        this.assertWebviewContext();
        return this.appModel.title;
    },
    async keys(value) {
        if (!this.focusedElId) {
            throw new driver_1.errors.InvalidElementStateError();
        }
        await this.setValue(value, this.focusedElId);
    },
    async setGeoLocation(location) {
        // TODO test this adequately once WD bug is fixed
        this.appModel.lat = location.latitude;
        this.appModel.long = location.longitude;
        return location;
    },
    async getGeoLocation() {
        return this.appModel.currentGeoLocation;
    },
    async getPageSource() {
        return this.appModel.rawXml;
    },
    async getOrientation() {
        return this.appModel.orientation;
    },
    async setOrientation(o) {
        if (!ORIENTATIONS.has(o)) {
            throw new driver_1.errors.UnknownError('Orientation must be LANDSCAPE or PORTRAIT');
        }
        this.appModel.orientation = o;
    },
    async getScreenshot() {
        return this.appModel.getScreenshot();
    },
    async getWindowSize() {
        return { width: this.appModel.width, height: this.appModel.height };
    },
    async getWindowRect() {
        return { width: this.appModel.width, height: this.appModel.height, x: 0, y: 0 };
    },
    async performActions(actions) {
        this.appModel.actionLog.push(actions);
    },
    async releaseActions() { },
    async getLog(type) {
        switch (type) {
            case 'actions':
                return this.appModel.actionLog;
            default:
                throw new Error(`Don't understand log type '${type}'`);
        }
    },
    async mobileShake() {
        this.shook = true;
    },
    async doubleClick() { },
    async execute(script, args) {
        return await this.executeMethod(script, args);
    },
    /**
     * Add two or maybe even three numbers
     */
    async fakeAddition(num1, num2, num3 = 0) {
        return num1 + num2 + (num3 ?? 0);
    },
    async getUrl() {
        return this.url;
    },
    async bidiNavigate(context, url) {
        this.url = url;
    },
};
(0, mixin_1.mixin)(GeneralMixin);
//# sourceMappingURL=general.js.map