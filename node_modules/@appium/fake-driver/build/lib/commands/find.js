"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const driver_1 = require("appium/driver");
const fake_element_1 = require("../fake-element");
const support_1 = require("appium/support");
const mixin_1 = require("./mixin");
const { W3C_WEB_ELEMENT_IDENTIFIER } = support_1.util;
async function findElOrEls(strategy, selector, mult, context) {
    const qMap = {
        xpath: 'xpathQuery',
        id: 'idQuery',
        'accessibility id': 'idQuery',
        'class name': 'classQuery',
        'tag name': 'classQuery',
        'css selector': 'cssQuery',
    };
    // TODO this error checking should probably be part of MJSONWP?
    if (!lodash_1.default.includes(lodash_1.default.keys(qMap), strategy)) {
        throw new driver_1.errors.UnknownCommandError();
    }
    if (selector === 'badsel') {
        throw new driver_1.errors.InvalidSelectorError();
    }
    const els = this.appModel[qMap[strategy]](selector, context);
    let retval;
    if (els.length) {
        if (mult) {
            const allEls = [];
            for (const el of els) {
                allEls.push(this.wrapNewEl(el));
            }
            retval = allEls;
        }
        else {
            retval = this.wrapNewEl(els[0]);
        }
    }
    else if (mult) {
        retval = [];
    }
    else {
        throw new driver_1.errors.NoSuchElementError();
    }
    return retval;
}
const FindMixin = {
    getExistingElementForNode(node) {
        for (const [id, el] of lodash_1.default.toPairs(this.elMap)) {
            if (el.node === node) {
                return id;
            }
        }
        return null;
    },
    wrapNewEl(obj) {
        // first check and see if we already have a ref to this element
        const existingElId = this.getExistingElementForNode(obj);
        if (existingElId) {
            return { ELEMENT: existingElId, [W3C_WEB_ELEMENT_IDENTIFIER]: existingElId };
        }
        // otherwise add the element to the map
        this.maxElId++;
        const maxElId = this.maxElId.toString();
        this.elMap[maxElId] = new fake_element_1.FakeElement(obj, this.appModel);
        return { ELEMENT: maxElId, [W3C_WEB_ELEMENT_IDENTIFIER]: maxElId };
    },
    findElOrEls,
    /**
     * This should override whatever's in ExternalDriver
     * @param {string} strategy Strategy
     * @param {string} selector Selector
     * @this {FakeDriver}
     */
    async findElement(strategy, selector) {
        return this.findElOrEls(strategy, selector, false);
    },
    async findElements(strategy, selector) {
        return this.findElOrEls(strategy, selector, true);
    },
    async findElementFromElement(strategy, selector, elementId) {
        const el = this.getElement(elementId);
        return this.findElOrEls(strategy, selector, false, el.xmlFragment);
    },
    async findElementsFromElement(strategy, selector, elementId) {
        const el = this.getElement(elementId);
        return this.findElOrEls(strategy, selector, true, el.xmlFragment);
    },
};
(0, mixin_1.mixin)(FindMixin);
//# sourceMappingURL=find.js.map